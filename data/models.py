import asyncio
import datetime
from typing import Union

import aiogram
from aiogram import types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.exceptions import RetryAfter
from django.db import models
from django.utils import timezone

from . import managers


menuKeyboard = InlineKeyboardMarkup(resize_keyboard=True, inline_keyboard=[
    [
        InlineKeyboardButton(text='üí¥ –°–¥–µ–ª–∞—Ç—å —Å—Ç–∞–≤–∫—É', callback_data='commands.bet'),
    ], [
        InlineKeyboardButton(text='üí¥ –ë–∞–ª–∞–Ω—Å', callback_data='commands.player.balance'),
        InlineKeyboardButton(text='üíº –°—Ç–∞–≤–∫–∏', callback_data='commands.bets'),
    ], [
        InlineKeyboardButton(text='üî• –†–µ–π—Ç–∏–Ω–≥', callback_data='commands.rating'),
        InlineKeyboardButton(text='‚öô –ù–∞—Å—Ç—Ä–æ–π–∫–∏', callback_data='commands.player.settings'),
    ]])


async def Debugger(func):
    while True:
        try:
            return await func
        except aiogram.utils.exceptions.BotBlocked:
            return False
        except RetryAfter as e:
            timer = int(str(e).split('.')[1].split()[2])
            await asyncio.sleep(timer)


class TGUser(models.Model):
    class Meta:
        verbose_name_plural = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ Telegram"

    id = models.IntegerField(primary_key=True, unique=True, verbose_name="ID")
    name = models.CharField(max_length=255, default='', verbose_name="–ò–º—è Telegram", blank=True)
    status = models.BooleanField(default=True, verbose_name="–°—Ç–∞—Ç—É—Å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –∞–∫–∫–∞—É–Ω—Ç–∞")
    admin = models.BooleanField(default=False, verbose_name="–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä")
    balance = models.BigIntegerField(default=1000, verbose_name="–ë–∞–ª–∞–Ω—Å")
    rating = models.BigIntegerField(default=1000, verbose_name="–†–µ–π—Ç–∏–Ω–≥")
    language = models.CharField(max_length=2, default='en', verbose_name="–Ø–∑—ã–∫–æ–≤–æ–π –ø–∞–∫–µ—Ç")
    tg_language = models.CharField(max_length=2, default='en',
                                   verbose_name="–Ø–∑—ã–∫–æ–≤–æ–π –ø–∞–∫–µ—Ç –≤ Telegram")

    def get_settings(self):
        try:
            return self.settings
        except:
            return Settings.objects.create(user=self)

    def __str__(self):
        if self.name:
            return self.name
        return f"user{self.id}"


class Settings(models.Model):
    class Meta:
        verbose_name_plural = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"

    user = models.OneToOneField(TGUser, on_delete=models.CASCADE, verbose_name='–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å',
                                default=None, blank=True)
    objects = managers.DefaultManager()
    news = models.BooleanField(default=True, verbose_name='–ù–æ–≤–æ—Å—Ç–∏')
    notification = models.BooleanField(default=True, verbose_name='–û–ø–æ–≤–µ—â–µ–Ω–∏—è')

    def __str__(self):
        return f"–ù–∞—Å—Ç—Ä–æ–π–∫–∏ {self.user}"


class Category(models.Model):
    class Meta:
        verbose_name_plural = "–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤–∏–¥–æ–≤ —Å–ø–æ—Ä—Ç–∞"

    name = models.TextField(default='', verbose_name="–ù–∞–∑–≤–∞–Ω–∏–µ")
    objects = managers.CategoryManager()

    def __str__(self):
        return f"{self.name.capitalize()}"


class SubCategory(models.Model):
    class Meta:
        verbose_name_plural = "–ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏"

    name = models.TextField(default='', verbose_name="–ù–∞–∑–≤–∞–Ω–∏–µ")
    category = models.ForeignKey(Category,
                                 on_delete=models.CASCADE,
                                 related_name='subcategories',
                                 verbose_name="–ö–∞—Ç–µ–≥–æ—Ä–∏—è")
    objects = managers.CategoryManager()

    def __str__(self):
        return f"{self.category} -> {self.name.capitalize()}"


class Tournament(models.Model):
    class Meta:
        verbose_name_plural = "–¢—É—Ä–Ω–∏—Ä—ã"

    name = models.TextField(default='', verbose_name="–ù–∞–∑–≤–∞–Ω–∏–µ")
    subcategory = models.ForeignKey(
        SubCategory,
        on_delete=models.CASCADE,
        related_name='tournaments',
        verbose_name="–ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è"
    )
    objects = managers.CategoryManager()

    def __str__(self):
        return f"{self.subcategory} -> {self.name}"


class Event(models.Model):
    class Meta:
        verbose_name_plural = "–°–æ–±—ã—Ç–∏—è"

    name = models.TextField(default='', verbose_name="–°–æ–±—ã—Ç–∏–µ")
    tournament = models.ForeignKey(
        Tournament,
        on_delete=models.CASCADE,
        related_name='events',
        verbose_name="–¢—É—Ä–Ω–∏—Ä"
    )
    parimatch_link = models.CharField(
        max_length=100,
        default='',
        verbose_name="–°—Å—ã–ª–∫–∞ –Ω–∞ PariMatch",
        blank=True
    )
    sports_ru_link = models.CharField(
        max_length=100,
        default='',
        verbose_name="–°—Å—ã–ª–∫–∞ –Ω–∞ Sports",
        blank=True
    )
    start_time = models.DateTimeField(
        default=datetime.datetime.utcnow,
        verbose_name="–í—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã"
    )
    ended = models.BooleanField(
        default=False,
        verbose_name="–°—Ç–∞—Ç—É—Å –æ–∫–æ–Ω—á–∞–Ω–∏—è —Å–æ–±—ã—Ç–∏—è",
        blank=True
    )

    objects = managers.EventManager()

    def __str__(self):
        return f"{self.name} (pk={self.pk})"

    async def close(self, bot: aiogram.Bot) -> bool:
        if self.ended:
            return False
        for _team in self.teams.all():
            bets: list[Bet] = _team.bets.filter(is_active=True, payed=False)
            for bet in bets:
                await bet.close(bot)
        self.ended = True
        self.save()
        return True

    async def win(self, team: "TeamEvent", bot: aiogram.Bot) -> bool:
        if self.ended:
            return False
        self.ended = True
        self.save()
        teams: list[TeamEvent] = self.teams.all()
        if team not in teams:
            return False
        for _team in teams:
            flag = _team.pk == team.pk
            bets: list[Bet] = _team.bets.filter(is_active=True, payed=False)
            for bet in bets:
                if flag:
                    await bet.win(bot)
                else:
                    await bet.lose(bot)
        return True


class Team(models.Model):
    class Meta:
        verbose_name_plural = '–ö–æ–º–∞–Ω–¥–∞'

    objects = managers.DefaultManager()

    def get_name(self) -> str:
        return str(self.names.get(primary=True))

    def __str__(self):
        try:
            return self.get_name()
        except TeamName.DoesNotExist:
            return 'team'


class TeamName(models.Model):
    class Meta:
        verbose_name_plural = '–ù–∞–∑–≤–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥'

    name = models.CharField(max_length=50, verbose_name='–ò–º—è')
    verified = models.BooleanField(default=False, verbose_name='–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–Ω—ã–π')
    denied = models.BooleanField(default=False, verbose_name='–û—Ç–∫–∞–∑–∞–Ω–Ω—ã–π')
    primary = models.BooleanField(default=False, verbose_name='–û—Å–Ω–æ–≤–Ω–æ–π')
    team = models.ForeignKey(Team, on_delete=models.CASCADE,
                             related_name='names', verbose_name='–ö–æ–º–∞–Ω–¥–∞')

    objects = managers.DefaultManager()

    def __str__(self):
        return self.name

    def __repr__(self):
        return f"<TeamName: {self.team}/{self.name!r}>"


class TeamEvent(models.Model):
    class Meta:
        verbose_name_plural = "–°—Ç–æ—Ä–æ–Ω—ã"

    team = models.ForeignKey(Team, on_delete=models.CASCADE, related_name="events", verbose_name='–ö–æ–º–∞–Ω–¥–∞')
    first = models.BooleanField(default=True, verbose_name="–•–æ–∑—è–∏–Ω –ª–∏ –ø–ª–æ—â–∞–¥–∫–∏?")
    event = models.ForeignKey(Event, on_delete=models.CASCADE,
                              related_name='teams', verbose_name="–°–æ–±—ã—Ç–∏–µ")
    bet = models.FloatField(default=1.0, verbose_name='–°—Ç–∞–≤–∫–∞')
    objects = managers.DefaultManager()

    def __str__(self):
        return f"{self.team} - {self.bet}"

    def create_bet(self, money: int, user: TGUser) -> Union["Bet", bool]:
        if user.balance >= money and Bet.objects.filter(user=user, team__event=self.event).count() == 0:
            user.balance = user.balance - money
            user.save()
            return Bet.objects.create(value=self.bet, money=money, user=user, team=self)
        return False


class Bet(models.Model):
    class Meta:
        verbose_name_plural = "–°—Ç–∞–≤–∫–∏"

    value = models.FloatField(default=1.0, verbose_name="–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç")
    money = models.IntegerField(default=10, verbose_name="–°—É–º–º–∞")
    user = models.ForeignKey(TGUser, on_delete=models.CASCADE,
                             related_name='bets', verbose_name="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å")
    team = models.ForeignKey(TeamEvent, on_delete=models.CASCADE,
                             related_name='bets', verbose_name="–ö–æ–º–∞–Ω–¥–∞")
    winner = models.BooleanField(default=False, verbose_name="–í—ã–∏–≥—Ä–∞–ª –ª–∏")
    is_active = models.BooleanField(default=True, verbose_name="–ê–∫—Ç–∏–≤–Ω–∞ –ª–∏ —Å—Ç–∞–≤–∫–∞")
    payed = models.BooleanField(default=False, verbose_name="–û–ø–ª–∞—á–µ–Ω–∞ –ª–∏ —Å—Ç–∞–≤–∫–∞")
    created_date = models.DateTimeField(default=timezone.now, verbose_name="–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è")
    express = models.ForeignKey("Express", on_delete=models.CASCADE, verbose_name='–≠–∫—Å–ø—Ä–µ—Å—Å', related_name='bets',
                                null=True, default=None)

    objects = managers.DefaultManager()

    async def close(self, bot: aiogram.Bot):
        if not self.is_active:
            return False
        self.user.balance = self.user.balance + self.money
        self.user.save()
        settings: Settings = self.user.get_settings()
        if settings.notification:
            await Debugger(bot.send_message(
                chat_id=self.user.id,
                text=f"<b>–°—Ç–∞–≤–∫–∞#{self.pk}</b> –æ–∫–∞–∑–∞–ª–∞—Å—å –æ—Ç–º–µ–Ω–µ–Ω–∞üî•\n"
                     f"–í–∞—à —Ä–µ–π—Ç–∏–Ω–≥ –æ—Å—Ç–∞–ª—Å—è –Ω–µ–∏–∑–º–µ–Ω–Ω—ã–º, "
                     f"–∞ —Å—Ç–∞–≤–∫–∞ –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∞ üí¥ {self.money}\n\n",
                parse_mode=types.ParseMode.HTML,
            ))
            await Debugger(bot.send_message(
                chat_id=self.user.id,
                text="–°–¥–µ–ª–∞–µ–º –µ—â—ë —Å—Ç–∞–≤–∫—É?",
                reply_markup=menuKeyboard
            ))
        self.delete()
        return True

    async def win(self, bot: aiogram.Bot):
        if not self.is_active:
            return False
        self.winner = True
        self.payed = True
        self.user.rating = self.user.rating + int(self.value * self.money - self.money)
        self.user.balance = self.user.balance + int(self.value * self.money)
        self.user.save()
        self.save()
        settings: Settings = self.user.get_settings()
        if settings.notification:
            await Debugger(bot.send_message(
                chat_id=self.user.id,
                text=f"<b>–°—Ç–∞–≤–∫–∞#{self.pk}</b> –æ–∫–∞–∑–∞–ª–∞—Å—å –≤—ã–∏–≥—Ä—ã—à–Ω–æ–πüî•\n"
                     f"–í–∞—à —Ä–µ–π—Ç–∏–Ω–≥ —É–≤–µ–ª–∏—á–∏–ª—Å—è –Ω–∞ ‚öúÔ∏è {int(self.value * self.money - self.money)}, "
                     f"–∞ –±–∞–ª–∞–Ω—Å –Ω–∞ üí¥ {int(self.value * self.money)}\n\n"
                     f"–ü–æ–¥—Ä–æ–±–Ω–µ–µ:\n{self.get_info()}",
                parse_mode=types.ParseMode.HTML,
            ))
            await Debugger(bot.send_message(
                chat_id=self.user.id,
                text="–°–¥–µ–ª–∞–µ–º –µ—â—ë —Å—Ç–∞–≤–∫—É?",
                reply_markup=menuKeyboard
            ))
        return True

    async def lose(self, bot: aiogram.Bot):
        if not self.is_active:
            return False
        self.payed = True
        self.user.rating = self.user.rating - int(self.money / self.value)
        self.user.save()
        self.save()
        settings: Settings = self.user.get_settings()
        if settings.notification:
            await Debugger(bot.send_message(
                chat_id=self.user.id,
                text=f"<b>–°—Ç–∞–≤–∫–∞#{self.pk}</b> –æ–∫–∞–∑–∞–ª–∞—Å—å –ø—Ä–æ–∏–≥—Ä—ã—à–Ω–æ–π(\n"
                     f"–í–∞—à —Ä–µ–π—Ç–∏–Ω–≥ —É–º–µ–Ω—å—à–∏–ª—Å—è –Ω–∞ ‚öúÔ∏è {int(self.money / self.value)}\n\n"
                     f"–ü–æ–¥—Ä–æ–±–Ω–µ–µ:\n{self.get_info()}",
                parse_mode=types.ParseMode.HTML,
            ))
            await Debugger(bot.send_message(
                chat_id=self.user.id,
                text="–°–¥–µ–ª–∞–µ–º –µ—â—ë —Å—Ç–∞–≤–∫—É?",
                reply_markup=menuKeyboard
            ))
        return True

    def get_info(self, active: bool = False) -> str:
        if self.express is None:
            team: str = self.team.team.get_name()
            if team != '–ù–∏—á—å—è':
                team = f"–ø–æ–±–µ–¥—É –∫–æ–º–∞–Ω–¥—ã {team}"
            else:
                team = '–Ω–∏—á—å—é'
            if active:
                if not self.is_active or self.payed:
                    return ""
            _header = f"–°—Ç–∞–≤–∫–∞#{self.pk}"
            if self.is_active is False:
                _header += " [–û—Ç–º–µ–Ω—ë–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º]"
            if self.payed:
                if self.winner:
                    _header += " [–°—Ç–∞–≤–∫–∞ –≤—ã–∏–≥—Ä–∞–Ω–∞] [–û–ø–ª–∞—á–µ–Ω–æ]"
                else:
                    _header += " [–°—Ç–∞–≤–∫–∞ –ø—Ä–æ–∏–≥—Ä–∞–Ω–∞]"
            return f"<code>{_header}\n" \
                   f"- –í–∏–¥ —Å–ø–æ—Ä—Ç–∞: <i><u>{self.team.event.tournament.subcategory.category.name.upper()}</u></i>\n" + \
                   f"- –ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è: <i><u>{self.team.event.tournament.subcategory.name.upper()}</u></i>\n" + \
                   f"- –¢—É—Ä–Ω–∏—Ä: <i><u>{self.team.event.tournament.name.upper()}</u></i>\n" + \
                   f"- –°–æ–±—ã—Ç–∏–µ: <i>{self.team.event.name!r}</i>\n" + \
                   f"- –ò—Å—Ö–æ–¥ –Ω–∞ <i>{team}</i> —Å –∫–æ—ç—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–º {self.value}\n" + \
                   f"- –°—É–º–º–∞ —Å—Ç–∞–≤–∫–∏: üí¥ {self.money}\n" + \
                   (f"- –í—ã–∏–≥—Ä—ã—à: üí¥ <b>{int(self.money * self.value)}</b>\n" if self.winner else "") + \
                   (f"- –í—ã–∏–≥—Ä–∞–Ω–æ —Ä–µ–π—Ç–∏–Ω–≥–∞: ‚öúÔ∏è<b>{int(self.money * self.value - self.money)}</b>\n" if self.winner else "") + \
                   (f"- –ü—Ä–æ–∏–≥—Ä–∞–Ω–æ —Ä–µ–π—Ç–∏–Ω–≥–∞: ‚öúÔ∏è <b>{int(self.money / self.value)}</b>\n"
                    if not self.winner and self.payed
                    else "") + \
                   (f"- –í–æ–∑–º–æ–∂–Ω—ã–π –≤—ã–∏–≥—Ä—ã—à: üí¥ {int(self.money * self.value)}\n" if not self.payed and self.is_active else "") + \
                   f"- –î–∞—Ç–∞ —Å–æ–±—ã—Ç–∏—è: {self.team.event.start_time} UTC\n" + \
                   f"- –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç–∞–≤–∫–∏: {self.created_date} UTC</code>\n\n"
        else:
            team: str = self.team.team.get_name()
            if team != '–ù–∏—á—å—è':
                team = f"–ø–æ–±–µ–¥—É –∫–æ–º–∞–Ω–¥—ã {team}"
            else:
                team = '–Ω–∏—á—å—é'
            return f"- –°–æ–±—ã—Ç–∏–µ: <i><u>{self.team.event.tournament.subcategory.category.name.upper()}/" \
                   f"{self.team.event.tournament.subcategory.name.upper()}/" \
                   f"{self.team.event.tournament.name.upper()}/{self.team.event.name!r}</u></i>\n" + \
                   f"- –ò—Å—Ö–æ–¥ –Ω–∞ <i>{team}</i> —Å –∫–æ—ç—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–º {self.value}\n" + \
                   f"- –°—É–º–º–∞ —Å—Ç–∞–≤–∫–∏: üí¥ {self.money}\n" + \
                   f"- –î–∞—Ç–∞ —Å–æ–±—ã—Ç–∏—è: {self.team.event.start_time} UTC\n" + \
                   f"- –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç–∞–≤–∫–∏: {self.created_date} UTC\n\n"


class TeamModeration(models.Model):
    class Meta:
        verbose_name_plural = "–ó–∞—è–≤–∫–∏"

    name = models.ForeignKey(TeamName, on_delete=models.CASCADE,
                             related_name='applications', verbose_name='–ò–º—è –Ω–∞ –∑–∞—è–≤–∫—É')
    message_id = models.IntegerField(default=0, verbose_name='ID —Å–æ–æ–±—â–µ–Ω–∏—è')

    objects = managers.DefaultManager()


class Express(models.Model):
    class Meta:
        verbose_name_plural = '–≠–∫—Å–ø—Ä–µ—Å—Å'

    payed = models.BooleanField(default=False, verbose_name='–û–ø–ª–∞—á–µ–Ω–æ')
    canceled = models.BooleanField(default=False, verbose_name='–û—Ç–º–µ–Ω–µ–Ω–æ')
    winner = models.BooleanField(default=False, verbose_name='–í—ã–∏–≥—Ä–∞–Ω–æ')
    money = models.IntegerField(verbose_name='–°—É–º–º–∞', default=100)
    created_date = models.DateTimeField(default=timezone.now, verbose_name="–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è")
    user = models.ForeignKey(TGUser, on_delete=models.CASCADE, verbose_name='–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å',
                             related_name='expresses')

    objects = managers.DefaultManager()

    def get_info(self, active: bool = False) -> str:
        expresses = ""
        k = 1
        if active and not self.payed and not self.canceled:
            for bet in self.bets:
                k *= bet.value
                _ = bet.get_info()
                if _ != '':
                    _ += "\n"
                expresses += _
        status = ""
        if self.payed:
            status += "[–í—ã–∏–≥—Ä–∞–Ω–æ] [–û–ø–ª–∞—á–µ–Ω–æ] " if self.winner else "[–ü—Ä–æ–∏–≥—Ä–∞–Ω–æ] "
        if self.canceled:
            status += "[–û—Ç–º–µ–Ω–µ–Ω–æ] "
        return f"<code>–≠–∫—Å–ø—Ä–µ—Å—Å ‚Ññ{self.pk} {status}" \
               f"- –°—Ç–∞–≤–∫–∞: {self.money}\n" + \
               f"- –í—ã–∏–≥—Ä—ã—à: {int(self.money*k)}" if self.payed else "" + \
               f"- –°—Ç–∞–≤–∫–∏:\n{expresses}</code>"

    def check_status(self):
        if self.canceled or self.payed:
            return False
        flag = True
        ended = True
        k = 1
        for bet in self.bets:
            k *= bet.value
            if bet.payed and not bet.winner:
                flag = False
            if not bet.payed:
                ended = False
        if ended:
            if flag:
                message = f"–í–∞—à —ç–∫—Å–ø—Ä–µ—Å—Å ‚Ññ{self.pk} –≤—ã–∏–≥—Ä–∞–Ω\n" \
                          f"–í–∞—à –≤—ã–∏–≥—Ä—ã—à: {int(self.money*k)}\n" \
                          f"–í–∞—à —Ä–µ–π—Ç–∏–Ω–≥ —É–≤–µ–ª–∏—á–µ–Ω –Ω–∞ {int(self.money*k)-self.money}"
            else:
                message = f"–í–∞—à —ç–∫—Å–ø—Ä–µ—Å—Å ‚Ññ{self.pk} –ø—Ä–æ–∏–≥—Ä–∞–Ω(\n" \
                          f"–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏: {self.money}\n" \
                          f"–í–∞—à —Ä–µ–π—Ç–∏–Ω–≥ —É–º–µ–Ω—å—à–µ–Ω –Ω–∞ {self.money}"
        return False
